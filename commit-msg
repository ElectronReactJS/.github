#!/usr/bin/env bash
# Script: hooks/commit-msg
# Author: Ricardo Malnati
# Creation Date: 2023-10-15
# Description: Analyzes the commit content and suggests a semantic versioning message. Supports user 
#               and project-level preferences for language and content.
# Dependencies: curl, jq, openssl

# Get the project directory using Git setup info
PROJECT_DIR=$(git rev-parse --show-toplevel)

# OS-agnostic home directory
HOME_DIR=$(eval echo ~$USER)

# Configuration and encryption file paths
CONFIG_FILE_PROJECT="$PROJECT_DIR/.anyhooksrc"
CONFIG_FILE_HOME="$HOME_DIR/.anyhooksrc"
ENCRYPT_FILE_PROJECT="$PROJECT_DIR/.anyhooksopenai.enc"
ENCRYPT_FILE_HOME="$HOME_DIR/.anyhooksopenai.enc"

# Check for configuration files, prioritize project directory
if [ -f $CONFIG_FILE_PROJECT ]; then
    source $CONFIG_FILE_PROJECT
elif [ -f $CONFIG_FILE_HOME ]; then
    source $CONFIG_FILE_HOME
else
    echo "Error: Configuration file not found."
    echo "Reason: The script requires a configuration file either in the project directory or the home directory."
    exit 1
fi

# Check for encrypted files, prioritize project directory
ENCRYPT_FILE=""
if [ -f $ENCRYPT_FILE_PROJECT ]; then
    ENCRYPT_FILE=$ENCRYPT_FILE_PROJECT
elif [ -f $ENCRYPT_FILE_HOME ]; then
    ENCRYPT_FILE=$ENCRYPT_FILE_HOME
else
    echo "Error: Encrypted API key file not found."
    echo "Reason: The script requires an encrypted API key file either in the project directory or the home directory."
    exit 2
fi

# Check for curl
if ! command -v curl &> /dev/null; then
  echo "Error: curl is not installed. Reason: The script requires curl for making API calls."
  echo "Developer Fix: Install curl via Homebrew by running 'brew install curl'."
  exit 3
fi

# Check for jq
if ! command -v jq &> /dev/null; then
  echo "Error: jq is not installed. Reason: The script requires jq for JSON parsing."
  echo "Developer Fix: Install jq via Homebrew by running 'brew install jq'."
  exit 4
fi

# Check for openssl
if ! command -v openssl &> /dev/null; then
  echo "Error: openssl is not installed. Reason: The script requires openssl for encryption and decryption."
  echo "Developer Fix: Install openssl via Homebrew by running 'brew install openssl'."
  exit 5
fi

# Source the variable
CONFIG_FILE="./.anyhooksrc"
if [ ! -f $CONFIG_FILE ]; then
    echo "Error: Configuration file $CONFIG_FILE not found."
    echo "Reason: The script requires this file for sourcing variables."
    echo "User Task: Make sure $CONFIG_FILE exists and is accessible."
    exit 6
fi

# Check for required files and variables
if [ ! -f $ENCRYPT_FILE ] || [ -z "$PASSPHRASE" ] || [ -z "$PREF_LANGUAGE" ] || [ -z "$OPENAI_SYSTEM_CONTENT" ] || [ -z "$OPENAI_USER_CONTENT" ]; then
    echo "Error: Required variables not set in $CONFIG_FILE."
    echo "Reason: Missing PASSPHRASE, PREF_LANGUAGE, OPENAI_SYSTEM_CONTENT, or OPENAI_USER_CONTENT."
    echo "User Task: Update $CONFIG_FILE with the missing variables."
    exit 7
fi

# Decrypt API Key
API_KEY=$(echo $PASSPHRASE | openssl enc -aes-256-cbc -d -pbkdf2 -in $ENCRYPT_FILE -pass stdin)

$(git add .)
DIFF_OUTPUT=$(git diff --cached)

# Prepare the JSON payload using jq
JSON_DIFF_OUTPUT_PAYLOAD=$(jq -n \
                  --arg model "gpt-3.5-turbo-16k" \
                  --arg sys_content "$OPENAI_SYSTEM_CONTENT The user speaks $PREF_LANGUAGE." \
                  --arg user_content "$OPENAI_USER_CONTENT: $DIFF_OUTPUT" \
                  '{model: $model, messages: [{role: "system", content: $sys_content}, {role: "user", content: $user_content}]}')

# Make an API call to ChatGPT for analysis
API_FROM_DIFF_OUTPUT_RESPONSE=$(curl -s -H "Authorization: Bearer $API_KEY" \
    -H "Content-Type: application/json" \
    -d "$JSON_DIFF_OUTPUT_PAYLOAD" \
    "https://api.openai.com/v1/chat/completions")

# Check if curl command was successful
if [ $? -ne 0 ]; then
    echo "Error: API call to ChatGPT failed."
    echo "Reason: The curl command did not execute successfully."
    echo "Developer Fix: If you believe this is a bug, please contribute by opening an issue on the GitHub repository."
    echo "Support: If you have a support contract, please contact support with error code 8."
    echo "Community Help: For community assistance, post your issue on Stack Overflow with the tag 'auto-commit-msg'."
    exit 8
fi

# Extract the commit message from the API response
DESCRIPTION=$(echo "$API_FROM_DIFF_OUTPUT_RESPONSE" | jq -r '.choices[0].message.content')

# Define system context with specific instructions for emoji usage and commit message format
OPENAI_SYSTEM_CONTENT="Format the commit message to follow Conventional Commits and Semantic Versioning. Start the header with an emoji that matches the commit type. The header must include a type, scope (optional), and a short description, followed by a body and a footer if necessary. Wrap lines at 100 characters."

# Define user task with clear instructions on commit message structure and emoji inclusion
OPENAI_USER_CONTENT="Create a commit message with the following structure and details: \
- Header with type, then a (scope emoji) between parenteses, then a double point ':', then a space and finally, the subject. \
  1) The header structure: <TYPE> (<SCOPE> üîç): <SUBJECT> \
  2) The header example: git commit -m 'MINOR(üé® style): footer size increased'.  \
  3) The header must start with 'type' followed by the scope and the emoji then followed by double point ':'. \
- The type can be (MAJOR|MINOR|PATCH) depending the changes. \
  1) MAJOR version when you make incompatible API changes. \
  2) MINOR version when you add functionality in a backward compatible manner. \
  3) PATCH version when you make backward compatible bug fixes. \
- The scope must including a name followed an emoji, arrounded by parenteses. Ex.: (fix üêõ). \
  1) build üî® (hammer): Changes that affect the build system or external dependencies. \
  2) ci ü§ñ (robot): Changes to CI configuration files and scripts. \
  3) docs üìö (books): Documentation only changes. \
  4) feat ‚ú® (sparkles): A new feature. \
  5) fix üêõ (bug): A bug fix. \
  6) perf üöÄ (rocket): A code change that improves performance. \
  7) refactor üß© (puzzle piece): A code change that neither fixes a bug nor adds a feature. \
  8) style üé® (artist palette): Changes that do not affect the meaning of the code (white-space, formatting, etc). \
  9) test üß™ (test tube): Adding missing tests or correcting existing tests. \
  10) animations üíÉ (dancer): Changes related to animations. \
  11) common üåê (globe with meridians): Common code changes that affect multiple parts of the project. \
  12) compiler üõ†Ô∏è (hammer and wrench): Changes to the compiler. \
  13) compiler-cli üñ•Ô∏è (desktop computer): Changes to the CLI for the compiler. \
  14) core üß± (brick): Changes to the core functionality. \
  15) elements üîç (magnifying glass tilted right): Changes to UI elements. \
  16) forms (pencil): Changes to form handling or form elements. \
  17) http üåê (globe with meridians): Changes related to HTTP protocol handling. \
  18) language-service üà≥ (empty character box): Improvements or fixes to language services. \
  19) platform-browser üåç (globe showing Europe-Africa): Changes affecting the browser platform. \
  20) platform-browserdynamic üåé (globe showing Americas): Dynamic browser platform changes. \
  21) platform-server üñ•Ô∏è (desktop computer): Changes affecting server-side platform. \
  21) platform-webworker üë∑ (construction worker): Changes related to web workers. \
  23) platform-webworker-dynamic ‚öôÔ∏è (gear): Dynamic changes related to web workers. \
  24) router üß≠ (compass): Changes to the routing system. \
  25) service-worker üë∑‚Äç‚ôÇÔ∏è (man construction worker): Changes related to service workers. \
  26) upgrade ‚¨ÜÔ∏è (upwards button): Changes for upgrading the system or dependencies. \
- Imperative mood, lowercase subject, without ending period." 

# Prepare the JSON payload using jq, incorporating the DESCRIPTION
JSON_DESCRIPTION_PAYLOAD=$(jq -n \
                  --arg model "gpt-3.5-turbo-16k" \
                  --arg sys_content "$OPENAI_SYSTEM_CONTENT" \
                  --arg user_content "$OPENAI_USER_CONTENT" \
                  --arg description "$DESCRIPTION" \
                  '{model: $model, messages: [{role: "system", content: $sys_content}, {role: "user", content: $user_content}, {role: "user", content: $description}]}')

# Make an API call to ChatGPT for analysis
API_FROM_DESCRIPTION_RESPONSE=$(curl -s -H "Authorization: Bearer $API_KEY" \
    -H "Content-Type: application/json" \
    -d "$JSON_DESCRIPTION_PAYLOAD" \
    "https://api.openai.com/v1/chat/completions")

# Check if curl command was successful
if [ $? -ne 0 ]; then
    echo "Error: API call to ChatGPT failed."
    echo "Reason: The curl command did not execute successfully."
    echo "Developer Fix: If you believe this is a bug, please contribute by opening an issue on the GitHub repository."
    echo "Support: If you have a support contract, please contact support with error code 8."
    echo "Community Help: For community assistance, post your issue on Stack Overflow with the tag 'auto-commit-msg'."
    exit 8
fi

# Extract the commit message from the API response
SUGGESTION=$(echo "$API_FROM_DIFF_OUTPUT_RESPONSE" | jq -r '.choices[0].message.content')

# Check if jq command was successful
if [ $? -ne 0 ]; then
    echo "Error: Failed to parse API response."
    echo "Reason: The jq command did not execute successfully."
    echo "Developer Fix: If you believe this is a bug, please contribute by opening an issue on the GitHub repository."
    echo "Support: If you have a support contract, please contact support with error code 9."
    echo "Community Help: For community assistance, post your issue on Stack Overflow with the tag 'auto-commit-msg'."
    exit 9
fi

# Update the commit message
echo -e "$SUGGESTION" > "commit-message.txt"
echo -e "$DESCRIPTION" >> "commit-message.txt"
git commit -F "commit-message.txt"
rm -f "commit-message.txt"
git fetch && git pull

exit 0
